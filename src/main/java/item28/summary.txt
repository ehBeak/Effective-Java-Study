배열보다는 리스트를 사용하라
[1] 배열과 제네릭 타입의 차이
1. 배열은 공변, 제네릭은 불공변(Foo1)
   * 공변: Super 하위 타입이 Sub이면, Super[]의 하위타입은 Sub[]가 가능하다.
2. 배열은 실체화(refiy)된다.
   * 배열은 런타임에도 자신이 담기로 한 원소의 타입을 인지하고 확인한다.
   * 반면에 제네릭은 타입정보가 런타임시에 소거된다.
1번, 2번의 이유로 배열과 제네릭은 잘 어우러지지 못한다 -> new List<E>[], new List<String>[] 이 불가

[2] 제네릭 배열을 만들지 못하게 막은 이유
1. 타입 안전하지 않기 때문 (Foo2)

* 실체화 불가 타입: 실체화 되지 않아서 런타임에는 컴파일 타임보다 타입 정보를 적게 가지는 타입

[3] 제네릭 배열을 못만들어서 아쉬운 점
1. 제네릭 컬렉션에서는 자신의 원소타입을 담은 배열을 반환하는 게 보통은 불가능하다.
2. 제네릭 타입과 가변인수 메서드를 함께 쓰면 해석하기 어려운 경고 메시지를 받게 된다.

[4]
1. 배열로 형변환할 때 제네릭 배열 생성 오류나 비검사 형변환 경고가 뜨는 경우
   대부분은 배열인 E[] 대신 컬렉션인 List<E>를 사용하면 해결된다.(Chooser)

정리
배열과 제네릭에는 매우 다른 타입 규칙이 적용된다.
배열은 공변이고 실체화 되는 반면, 제네릭은 불공변이고 타입 정보가 소거된다.
그 결과 배열은 런타임에는 타입 안전하지만 컴파일 타임에는 그렇지 않다
반대로 제네릭은 컴파일 타임에는 타입이 안전하고 런타임에서는 그렇지 않다(컴파일에서 잡아준다)
때문에 둘을 섞어 쓰기가 쉽지 않다.
둘다 섞어 쓰다가 컴파일 오류나 경고를 만나면, 가장 먼저 배열을 리스트로 대체하는 방법을 적용하자